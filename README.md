# Programming-linguistics
컴퓨터공학과 프로그래밍 언어론 정리입니다.
[BNF](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hamill_a&logNo=221125554113)
[4](https://blog.naver.com/PostView.nhn?blogId=bh5kks&logNo=220498445612)
![image](https://github.com/wonchihyeon/Programming-linguistics/assets/58906858/532d1fb1-1f40-4e6c-957d-fd56aa0d6d9b)
![image](https://github.com/wonchihyeon/Programming-linguistics/assets/58906858/be821b10-a10b-407c-aee6-3578397112e9)
```
assign은 변화가능한 variable expression으로 유도가 가능하다.
LHS 정의하려는 추상화 : RHS는 토큰, 어휘항목, 다른 추상화에 대한 참조로 구성

논터미널 기호 혹은 논터미널 : 추상화된 대상
터미널 기호 혹은 터미널 : 규칙에 포함된 어휘항목과 토큰
논터미널 기호는 두 개 이상의 다른 정의를 가질 수 있음

리스트 명세 가변 길이의 리스트를 표현할 때 BNF에서는 재귀를 사용

최좌단 유도 -> 파스트리 -> 파스트리 구축 -> 유도 o 문제 x

문법의 모호성을 제거하는 방법 : 연산자의 우선순위, 연산의 결합 규칙

연산자 우선순위가 있고 없고의 차이가 있다.
연산자 우선순위는 낮은쪽에서부터 계산된다.
낮은 쪽이 먼저 생성되므로 연산자 우선 순위에 따라서 연산을 수행하므로 모호성을 제거한다.
(깊이 우선)

연산의 결합규칙
좌결합규칙: 좌순환적 표현은 좌결합 규칙을 기술한다. RHS의 시작 위치에 LHS가 나타나는 경우
우결합규칙: LHS가 RHS의 오른쪽 끝에 나타나는 경우
좌측의 <factor>가 우측에도 나타난다.<factor>

if then else를 위한 모호하지 않은 문법 else의 위치가 어디에 있을까

Dangling else 문제 if if else < 아무것도 출력이 안된다. 
if else if < 출력

if if else if statment?

BNF보다 서술 능력이 향상된 것은 아니며 단지 가독성과 작성력만 향상

<> 가 있는 건 논 터미널
-> 유도
<program> -> begin <> end -> <>
A = B + C; <- 터미널   

최좌단 유도 논미널 <> -> 터미널로 유도

구조상 파스트리와 같다.
중간 노드는 논터미널
잎 노드는 터미널
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/77c1ed68-fa4d-47b6-97e1-eed7d43b081c)

```
문법의 모호성 ? -> 주어진 한 문장에 대해 두 개 이상의 다른 파스트리를 생성할 경우
컴파일러가 의미를 결정할 수 없기 때문에

모호할 경우 해결책 -> 문법의 재작성, 비문법적 정보를 제공하여 하나의 올바른 파스트리를 구성

해결책으로 연산자 우선순위를 도입

낮은 곳이 먼저 계산된다. 우선순위가 높은 것을 파스트리의 최하단에 위치하게 함

if else -> 두 개의 파스트리(모호하다)

else 규칙 : 이전에 매칭되지 않은 가까운 then 에 매칭이 된다.
<match>, <unmatch> 나누어서 작성


yacc 구문 생성기가 parse 구문 분석기를 생성한다.

c,c++ 컴파일러
java 인터프리터

어휘분석과 구문 분석과 분리하는 이유

어휘분석(토큰과 렉심으로 구분) 토큰화 토큰, lexeme가 의미 -> 심볼 쌍을 이룬다.

어휘분석기의 역할 -> 주석제거, 심볼 테이블 구축, 어휘 에러 탐지 및 통보

어휘분석기 -> lex 정규 표현식을 사용한 lex, 패턴을 정의하는 상태 전이도, 상태전이도에 대한 테이블 구동 구현을 직접 구성

유한 오토마타 -> 유향 그래프

. 의미를 박탈해라 영문자가 여러개 오고 숫자가 오면 id다
스페이스 -> 뛰어넘어라

구문 분석의 목적 (파서의 역할)

파스트리를 구축

하향식-> 위에서 아래로 최좌단 유도와 같은 순서 LL 파서, 재귀 하향 파싱
상향식-> 아래에서 위로 최우단 유도의 역순 LL 파서, 이동-감축 알고리즘 yacc

파싱 알고리즘 복잡도 O(n^3) 소스코드에 비례
상업적 파서의 복잡도를 O(n)으로 줄임

최좌단,우단이던 파스트리는 하나만 생성

하향식 <- 재귀 하향 파싱 , 전역 변수 nextToken 파싱할 때 다음 토큰을 미리본다. LL 문법
좌측에서 1개의 터미널
하향식 <- LL , 재귀

expr term factor ( expr term factor sum expr + expr term factor 47 - 최종적으로 expr 다시

직접 좌순환 <- 재귀호출로 인한 스택오버플로우 발생
간접 좌순환 <- A -> BaA A가 즉시 자신을 호출하는 부분이 발생

하향식 순환을 안쓰는 데에는 이유가 있다.

상향식 순환을 자주 사용한다.

집합쌍 불일치 테스트
nextToken(lookahead)이 하나여야하는데 여러 경우면 안된다. 여러 경우면 RHS를 선택할 수 없다.

A 논터미널 a터미널 first의 집합의(a, b, c, d) 교집합이 공집합이므로(disjoin)하므로
하향식 파싱이 가능하다.

first가 a, a, b 서로 disjoint 하지 않으므로 하향식 파싱이 불가능하다.
```
[스택과 힙](https://blog.naver.com/gothevole/223232263442)
```
스택 : 지역변수, 함수 호출(지역변수,리턴되는 주소, 파라미터), 컴파일러
힙 : 동적으로 할당, 프로그래머가 관리

extern 전역변수 -> Data영역
실행->로더가 프로그램을 올려준다. 메모리 상에 코드부분은 코드부분
데이터는 데이터부분, stack, heap

code, data, stack, heap
os

스택에는 main부터 쌓음
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/b62c5f2e-11e9-4ffa-9804-76bed8b281ca)
```
상향식 파싱 최우단 유도의 역순

입력은 shift 토큰 스트림
출력은 발견된 문법 규칙

shift - Reduce 알고리즘

푸시다운 오토마타 문법에대한 인식
모든 파서는 푸시다운 오토마타
재귀 하강 파서도 푸시다운 오토마타

LR 파서의 장점, 단점을 서술하라

LR파서는 상대적으로 작은 파서코드와 파싱테이블로 구성
LR파서는 LL파서로 처리가능한 문법을 모두 처리 가능하다
LR파서는 적은 파서코드로도 LL파서로 처리가능한 문법을 모두 처리 가능하다.

단점 : 파싱테이블을 수작업으로 구축하기가 어렵다.
문법을 입력받아서 파싱테이블을 자동으로 생성하는 Yacc 프로그램이 존재한다.

0id5 스택 0, (id, 5) -> 0,(F,3) -> 0,(T,2)

중간고사 시험

LR 파싱테이블 ACTION이 어떻게 일어날까 
하향식 파서 처리부분

변수(타입 주소 값, 바인딩, 바인딩 시간)
영역(scope, lifetime)
초기화

폰노이만의 컴퓨터 추상화 데이터를 저장과 데이터 가공을 위한 연산으로 구성
메모리 셀에 대한 추상화 -> 변수, 배열 등 

```
### 반대로
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/e0a85559-4484-496d-8cc6-b0eef9320d3c)
```
0 <- 스택에
5 <- R6 Reduce6 id가 f가되고 상태를 변화 감축되고 난 후에 상태 변화
0F3 상태가 0에서 3이됨
3, + -> R4

1, + S6

문법을 반대로

0 E 1 4 6 T 1 8 7 f 10

t * f -> t

0 E 1 4 6 T 10

6,T -> 9

0 E 1 4 6 T 9

E+T -> E

0 E -> 1

0 E 1
```

```
변수의 속성(타입, 주소, 값)이 설정되는 시점이 다 다르다.
변수의 속성이 설정되는 시점이 바인딩 시간

변수는 영역, 존속 기간이 있다.

변수(타입, 주소, 값, 영역, 존속기간)

예외를 허용하지 않는 순수 함수형 언어에서의 변수는 값의 변경을 허용하지 않는다.

이름 case sensitive 대소문자구별

특수어 : if, for, while 프로그래밍 언어에서 수행할 행동들을 명칭화한 것.
예약어 : 특수어는 예약어로 분류, 특별한 의미로 해석하도록 선정이 되어있는 것.
키워드 : integer, float같은 자료형 처럼 어떤 문맥에서만 특별하게 사용되는 단어.

함수에서 자기 자신을 호출하는 경우 지역변수, 매개변수, 리턴값이 메모리의 영역을 벗어나는
세그먼테이션 오류가 발생한다.

스택변수 : 동일한 변수가 다른 시점에 다른 주소와 연관되는 것이 가능
L-value : 배정문의 좌측에 위치 값의 좌측에 놓인다. x = 3 (x는 변수, 좌측)

포인터 -> 별칭인데 가독성을 떨어뜨리는 요소가 된다.

x = x + 3

L-value -> x의 주소
R-value -> x + 3 -> x의 내용에 3 더하고 x의 주소에 넣어라

스택,데이터 영역 -> 이름있는 변수
힙 -> 이름없는변수

변수는 이름이 있을수도 있고 없을 수도 있다.

타입 : 변수가 저장할 수 있는 값들의 범위와 연산들의 집합을 결정

바인딩 : 속성과 개체간의 연관

언어 설계 시간 design : * 곱셈기호(포인터)
언어 구현 implementation 시간 C언어의 int type 1워드<-레지스터크기에 따라 다름 사이즈

edit time = desigin + implementation

컴파일 시간 : c, java 변수와 타입

링크 시간

로딩 시간 : 전역변수와 그의 주소
실행 시간 : 지역 변수와 그의 주소(main함수에서 콜이된 다음 설정)

자바에서 값의 사이즈가 설계 시간에 바딩 < 자바는 자바 virtual machine 설계 시간때 값의 범위 결정

실매개변수와 형식 매개변수 간의 바인딩이 어떻게 일어나는가 <- 실행 단계

실행단계 전에서 바인딩된다. 정적바인딩
실행 시간 중이거나 실행 과정에서 바인딩이 변경 될 수 있는 경우 -> 동적바인딩

하드웨어 바인딩은 고려하지 않음
os가 개입하는 가상메모리와 실메모리사이의 매핑(바인딩)은 고려 x

정적 타입 바인딩 <- 컴파일 시에 변수의 타입이 결정 됨
명시적 선언 : 컴파일러 방식, 변수 이름들을 나열하고 타입을 명세
묵시적 선언 : 컴파일러 방식이나 인터프리터 방식

명시적인것이 묵시적인것보다 좋다

타입 추론 var <- 실행시간이 아닌 컴파일 시간에 결정

동적 타입 바인딩 <- 변수의 타입이 명세 x 순수 인터프리터 언어 파이썬, 자스, c#
```
## 23.11.03

```
존속기간 = 기억장소에서 할당되고 회수되기 까지의 시간 (시간적인 개념)

정적 변수 <- 전역 변수, 정적 지역 변수에 해당. static 지정자는 클래스 변수를 생성
->장점 : 어디에서나 존재하므로 프로그램의 어느 부분에서나 직접적 접근이 가능
할당과 회수를 위한 부담이 없다. 할당하고 회수는 한 번만 이루어짐

->단점 : 유연성이 감소한다. 재귀적 호출x 스택을 이용하지 못하기 때문에

스택- 동적 변수 : 실행될 때 기억 공간에 바인딩 타입은 정적이지만 공간만 동적 바인딩되고 나머지 속성은 정적 바인딩
c함수, java 메서드의 지역변수, 매개 변수,
-> 장점 : 각 부프로그램 마다 자신의 기억 공간을 가짐
재귀 부프로그램의 작성에 활용

-> 단점 : 미미하지만) 할당과 회수에 따른 실행-시간 부담
간접 주소지정 방식으로 접근하므로 정적 변수보다는 느림
부프로그램이 과거 데이터의 접근에 제약
CPU Time을 미미하게 잡아먹음

명시적 힙 동적 변수
프로그래머가 명시적으로 실행시간 명령어에 의해서 할당되고 회수되는 이름없는 메모리 셀
c언어 :프로그래머가 관리하지 않는 힙
-> 장점 : 리스트나 트리와 같이 실행시간에 동적으로 크기가 변하는 자료구조 구축

-> 단점 : 프로그래머가 사용하기 어려움, 7포인터와 참조 변수의 올바른 사용의 어려움
참조비용, 기억 공간 관리 구현의 복잡성 등

힙공간에 접근할 수 없는 공간이 많아지는 현상 -> memory leaking 메모리 누수

암묵접 힙 동적 변수 (파이썬, 자바스크립트)
값이 배정될 때 힙 기억 장소에 바인딩
값이 배정될 때마다 변수의 모든 속성이 바인딩 됨

장점 : 유연성과 일반화 프로그램 작성에 유리
단점 : 실행시간에 속성을 관리해야함으로 비용이 많이듬
컴파일러에 의한 오류 탐지 능력 상실

```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/15cd3e68-239a-4c61-b0e6-57718797d38c)
```
정적 변수, 스택, 힙이 각각 잡혔다가 사라지는 시간들이 각각 다르다.
main의 시작과 끝 안에 foo의 시작과 끝안에 malloc의 시작과 끝이 있다.
 free(pi) pi가 가리키는 공간 ->heap의 공간이 없어지는데 pi는 있음
```
```
참조 가능한 변수 <- 변수가 가시적이다.(visible)

영역 규칙 : 이름을 어느 변수와 연관을 짓게 할 것인가를 결정하는 규칙

지역 변수 vs 비지역 변수

지역 변수 : 블록 내에 선언된 변수
비지역 변수 : 프로그램이나 블록 내에는 선언되어 있지 않지만 해당 영역에서 가시적인 변수
전역 변수가 비지역 변수의 한 예
함수 안의 변수 밖의 전역 변수

정적 영역 : static rule이 정해져있음 실행시간에 앎 프로그래머가 프로그래밍 한 시점에 알 수 있다.

변수의 영역이 변수의 선언/위치 그리고 부프로그램들의 상호 간의 공간적 배치 관계에 의하여 결정 -> 실행을 안시켜봐도
프로그램을 보면 변수가 어디에 쓰였는 지, 함수와의 관계를 볼 때 결정할 수 있다.

정적 언어 : c, c++, java 변수의 영역을 실행 전에 알 수 있다. scoping rule은 실행전에 결정될 수 있음

두 가지 형태의 정적 영역 언어가 존재

함수 안에 함수를 생성할 수 있는 언어 -> Ada, JavaScript, Common LISP, Scheme, Python

가능하지 않는 언어 -> C기반 언어들 C, C++, JAVA
중첩은 허용치 않으나 중첩된 클래스 정의나 블록에 의해서 중첩된 정적 영역 생성 가능
함수 안에 블록을 넣어서 중첩된 정적 영역을 생성 가능하다.
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/92f75322-f2d5-4839-9299-2940a7f87356)
```
var변수나 함수를 hoisting

big(부모영역), sub1, sub2(자식영역)

nonlocal인 영역은 다른 영역(부모영역)
sub2의 영역에 x가 없을 때 자기 영역에서 찾는데 없음 -> 부모 영역(big 영역에서 x를 찾음 var x = 3;)
sub2의 y는 3이 찍힘

sub1은 7이 찍힘

big영역의 x는 7이 찍힘

지역 변수 > 외부변수
local > nonlocal

LEGB룰 로컬에서 찾고 Enclosed, global, built-in-> 없으면 NameError

sub1은 x = 3
sub2의 입장에서 sub2 enclosed x=2
rpint(X)마지막 입장에서 local은 x= 2
big() x=2

블록 : 변수의 참조 가능한 영역을 최소화하는 효과 <- 좁으면 좁을 수록 에러를 찾기 쉬움
블록 내에 생성된 영역은 스택과 동일 취급 블록에 진입될 때 확보됬다가 빠져나올 때 회수 <- 함수콜의 처리방식과 같다.
C,C++은 중첩된 함수를 허용하지 않음
```
![image](https://github.com/chihyunwon/Programming-linguistics/assets/58906858/30d87852-a9dc-4b94-a87f-bf40e8fea55e)
```
int x = 0; 은 데이터영역에
int x = 1 스택
int x = 2 스택 안의 스택에

지역우선 -> 블록에서나오면 스택에서 사라짐,-> x= 2 블록에 빠져나오고 -> x = 1; (3, 2, 1)

지역변수>전역변수인데 전역 쓰려면 c는 extern 키워드를 c++는 ::연산자를 사용한다.

java는 중첩 블록은 허용하지만 변수명이 중복되는 경우를 배제

js는 함수 블록은 제공 python은 블록기호가 없음
```
```
6.11 pointer와 reference type
11.1
11.2
11.3 pointer의 문제점들
11.4 c와 c++에 있는 포인터들
5 reference type
6
7

311p까지 정리
위키피디아에서 가능
```



















